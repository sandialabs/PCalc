/**
 * Copyright 2009 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government
 * retains certain rights in this software.
 * 
 * BSD Open Source License.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of Sandia National Laboratories nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package gov.sandia.gnem.dbutillib;

import gov.sandia.gnem.dbutillib.dao.DAODatabase;
import gov.sandia.gnem.dbutillib.jaxb.ObjectFactory;
import gov.sandia.gnem.dbutillib.util.DBDefines;
import gov.sandia.gnem.dbutillib.util.DBDefines.FatalDBUtilLibException;

import javax.xml.bind.JAXBException;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * This class handles the encapsulation of the data contained in one "row" of a database. A Row can come from a
 * database, a flat file or an XML file. A Row must be associated with a Table object which contains the Row's table
 * name, table type, column information, primary key column names, etc. An effort has been made to make Row objects
 * small since typically quite a few of them are hanging out in memory at once.
 */
public class Row implements Cloneable {
    /**
     * Table object this Row is associated with.
     */
    private Table table;

    /**
     * Values for this Row. The order of the values corresponds to the order of the Columns in the Column array within
     * this Row's Table.
     */
    private Object[] values;

    /**
     * This row's name made up of the values of the primary keys for its Table as found in this Row.
     */
    private String name;

    /**
     * This is the name of the data source from which this Row originated. For Rows from a database, this should be the
     * username of the DB. For Rows that originated from files, it should be the directory name. For rows generated by
     * applications, it should be set to the name of the application.
     */
    private String dataSource = null;

    /**
     * Unique identifier for this Row based on an MD5 hash.
     */
    private RowID rowId = null;

    /**
     * This row's "status" in the context of what happened to it during a merge operation.
     */
    private int status = DBDefines.UNDETERMINED;

    /**
     * SQL to undo changes that have been made to this row.
     */
    private String sqlUndo = null;

    /**
     * Can be used to record processing that happens to a particular Row object in the context of a merge operation.
     */
    public StringBuffer history = null;

    /**
     * Information about an error that may be associated with a particular Row object. During row graph construction,
     * when this row is the source row, and execution of any of its relationship objects generates a constraint
     * violation, then the sql select statement that generated the violation is added to this list.
     */
    private LinkedList<String> errors = null;

    /**
     * Constructor that populates row data with values. Any values that are null are set equal to the NAValue
     * appropriate for the corresponding column. If an element is null and the NAValue is NOT ALLOWED, a fatal exception
     * is thrown.
     *
     * @param table      table this row belongs to
     * @param values     column name->data; data is assumed to be of a type appropriate for the column type where column
     *                   type information is defined in table.
     * @param areStrings whether or not the values are strings. If they are not strings, the data is assumed to be the
     *                   correct type for the column it is associated with. If they are strings, the data will be cast to the correct
     *                   object type.
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Row(Table table, HashMap<String, Object> values, boolean areStrings) throws FatalDBUtilLibException {
        this(table, values, areStrings, true);
    }

    /**
     * Constructor that populates row data with values. Any values that are null are set equal to the NAValue
     * appropriate for the corresponding column. If an element is null and the NAValue is NOT ALLOWED, a fatal exception
     * is thrown.
     *
     * @param table       table this row belongs to
     * @param values      column name->data; data is assumed to be of a type appropriate for the column type where column
     *                    type information is defined in table.
     * @param areStrings  whether or not the values are strings. If they are not strings, the data is assumed to be the
     *                    correct type for the column it is associated with. If they are strings, the data will be cast to the correct
     *                    object type.
     * @param createRowId whether or not to create a row id for this row. This should only be false if the rowid is
     *                    going to be set manually as is the case in {@link #fromJaxb(gov.sandia.gnem.dbutillib.jaxb.Row, Table) fromJaxb}
     * @throws FatalDBUtilLibException if an error occurs
     */
    // Matlab turns Strings of length one into Characters, which required special handling when HashMap<String,Object>
    // was just HashMap. Be alert to this issue if it arises again.
    private Row(Table table, HashMap<String, Object> values, boolean areStrings, boolean createRowId)
            throws FatalDBUtilLibException {
        if (table == null)
            throw new FatalDBUtilLibException("Error in Row constructor. Cannot construct a Row whose Table is null.");
        this.table = table;

        // Populate the values array from the values hashmap
        Column[] columns = table.getColumns();
        this.values = new Object[columns.length];

        for (String columnName : values.keySet()) {
            int index = table.getColumnIndex(columnName);
            if (index < 0)
                throw new FatalDBUtilLibException("ERROR in Row constructor for a " + getTableType() + " row.\n"
                        + "Trying to set the value of the " + columnName + " column but " + getTableType()
                        + " does not have a column by that name.");

            if (areStrings)
                // Convert from String to correct object type
                this.values[index] = columns[index].cast(String.valueOf(values.get(columnName)));
            else
                this.values[index] = values.get(columnName);
        }

        // Check for allowable NA values
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] == null) {
                this.values[i] = columns[i].getNAValue();
                if (!columns[i].NAValueAllowed())
                    throw new FatalDBUtilLibException("Error in Row constructor for a " + getTableType()
                            + " row.\nColumn " + columns[i].getName()
                            + " has NAValue = NOT ALLOWED but no value was supplied.");
            }
        }
        this.dataSource = null;
        if (!createRowId)
            return;

        try {
            this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            throw new FatalDBUtilLibException("Error in Row constructor when creating RowID. " + e.getMessage());
        }
    }

    /**
     * Constructor that populates row data with values. Any values that are null are set equal to the NAValue
     * appropriate for the corresponding column. If an element is null and the NAValue is NOT ALLOWED, a fatal exception
     * is thrown.
     *
     * @param table      table this row belongs to
     * @param values     to populate the row with. This must have the same number of elements as the table has columns and
     *                   the objects are assumed to be in the same order as the columns in the table. (So, values[i] is this row's value
     *                   for table.getColumns()[i])
     * @param areStrings whether or not the values are strings. If they are not strings, the data is assumed to be the
     *                   correct type for the column it is associated with. If they are strings, the data will be cast to the correct
     *                   object type.
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Row(Table table, Object[] values, boolean areStrings) throws FatalDBUtilLibException {
        this(table, values, null, areStrings);
    }

    /**
     * A Row constructor that populates the data fields with values that need not have the same number of elements as
     * the table has columns. indexMap[] defines the indexing relationship between the supplied values[] array and the
     * values[] array stored in the Row object. In other words, values[i] will be stored in Row.values[indexMap[i]]. Any
     * entries in indexMap which are < 0 or >= table.getColumns().length are ignored without warning. If the calling
     * application has a List of column names and populates the values[] array in the same order as the List of column
     * names, then the int[] returned by the {@link Table#getColumnIndexes Table.getColumnIndeces()} method can be
     * supplied to this Row constructor and the appropriate columns will be populated. Any values that are null are set
     * equal to the NAValue appropriate for the corresponding column. If an element is null and the NAValue is NOT
     * ALLOWED, a fatal exception is thrown.
     *
     * @param table      table this row belongs to
     * @param values     to populate the row with. This must have the same number of elements as the table has columns and
     *                   the objects are assumed to be in the same order as the columns in the table. (So, values[i] is this row's value
     *                   for table.getColumns()[i])
     * @param indexMap   defines the mapping from the indices in the supplied values[] array and the new Row's internal
     *                   values[] array (see comments for method). This must be the same length as the values array.
     * @param areStrings whether or not the values are strings. If they are not strings, the data is assumed to be the
     *                   correct type for the column it is associated with. If they are strings, the data will be cast to the correct
     *                   object type.
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Row(Table table, Object[] values, int[] indexMap, boolean areStrings) throws FatalDBUtilLibException {
        if (table == null)
            throw new FatalDBUtilLibException("Error in Row constructor. Cannot construct a Row whose Table is null.");
        this.table = table;

        Column[] columns = table.getColumns();
        this.values = new Object[columns.length];
        // values[i] as handed in is expected to correspond to the columns[i]
        if (indexMap == null) {
            if (values.length != this.values.length) {
                StringBuilder error = new StringBuilder("Error in Row constructor for a " + getTableType()
                        + "row. The number of specified values does not match the number of columns for the "
                        + getTableName() + " table and no indexMap was specified.\n\tColumns =");
                for (Column col : columns)
                    error.append(" " + col.getName());
                error.append(".\n\tValues =");
                for (Object val : values)
                    error.append(" " + val);
                throw new FatalDBUtilLibException(error.toString());
            }

            // cast the strings in values[] to objects in this.values[]
            if (areStrings) {
                for (int i = 0; i < values.length; i++) {
                    if (values[i] == null || values[i].toString().compareToIgnoreCase("null") == 0)
                        this.values[i] = null;
                    else if ((String.valueOf(values[i])).length() == 0)
                        this.values[i] = columns[i].getNAValue();
                    else
                        this.values[i] = columns[i].cast(values[i].toString());
                }
            }
            // copy the objects straight into this.values.
            else
                for (int i = 0; i < values.length; i++)
                    this.values[i] = values[i];
        }

        // map the objects from values[] into this.values[], using the index mapping supplied in indexMap[]. It must be
        // true that values.length == indexMap.length.
        else {
            if (this.values.length != indexMap.length)
                throw new FatalDBUtilLibException("Error in Row constructor for a " + getTableType()
                        + "row. An indexMap was specified to map the specified values to Row values "
                        + "but the indexMap and the specified values arrays are not the same size. \n\tvalues "
                        + "(as Object[]: " + Arrays.asList(values) + "\n\tindexMap: " + Arrays.asList(indexMap)
                        + "\nvalues length != indexMap length.");

            // cast the strings in values[] to objects in this.values[] using the specified mapping
            if (areStrings) {
                for (int i = 0; i < indexMap.length; i++) {
                    int j = indexMap[i];
                    if (j >= 0 && j < this.values.length)
                        this.values[j] = columns[j].cast((String) values[i]);
                }
            }
            // copy the objects straight into this.values using the specified mapping
            else
                for (int i = 0; i < indexMap.length; i++) {
                    int j = indexMap[i];
                    if (j >= 0 && j < this.values.length)
                        this.values[j] = columns[j].cast((String) values[i]);
                }
        }

        // If allowed, insert NAValues for the values for each column if they are null.
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] != null)
                continue;
            this.values[i] = columns[i].getNAValue();
            if (!columns[i].NAValueAllowed())
                throw new FatalDBUtilLibException("Error in Row constructor for a " + getTableType()
                        + "row. null specified for " + columns[i].getName() + " column but NAValues are not allowed.");
        }

        this.dataSource = null;
        try {
            this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            throw new FatalDBUtilLibException("Error in Row constructor when creating RowID. " + e.getMessage());
        }
    }

    /**
     * Constructor that creates a Row from the specified Row that belongs to the specified Table. This constructor
     * copies values from the specified row into the new row if those values are allowed in the specified table. If the
     * new row and the old row are associated with different Tables, then only values from columns that have the same
     * names in the two tables are copied. All other columns in the new Row will be set to NAValues, if that is allowed.
     * (An exception will be thrown if it is not allowed.)
     *
     * @param row   row whose values are to be copied into the new Row
     * @param table table the newly constructed row belongs to.
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Row(Row row, Table table) throws FatalDBUtilLibException {
        if (table == null)
            throw new FatalDBUtilLibException("Error in Row constructor. Cannot construct a Row whose Table is null.");
        this.table = table;
        if (row.history != null)
            this.history = new StringBuffer(row.history.toString());

        // Initialize values to have as many entries as there are columns in the new table.
        Column[] columns = this.table.getColumns();
        this.values = new Object[columns.length];

        // Set the new values from the old values
        for (int i = 0; i < this.values.length; i++) {
            // i is the index of the value for the new row
            // set j to the index of column with the same name in the specified row
            int j = row.getTable().getColumnIndex(columns[i].getName());

            // The old row does not have a column that corresponds to a column in this new row. If an navalue can be
            // used, do that. Otherwise, this row is invalid and an error must be generated.
            if (j < 0) {
                if (columns[i].NAValueAllowed())
                    this.values[i] = columns[i].getNAValue();
                else {
                    String error = "Error in Row constructor. Trying to create a new row belonging to the "
                            + getTableType() + " table from this row: " + row + " whose belonging to a "
                            + row.getTableType() + "table. " + getTableType() + "'s " + columns[i].getName()
                            + " column does not allow NAValues, but the specified "
                            + "row does not have a value for that column.";
                    throw new FatalDBUtilLibException(error);
                }
            } else if (row.values[j] == null && !columns[i].NAValueAllowed()) {
                String error = "Error in Row constructor. Trying to create a new row belonging to the "
                        + getTableType() + " table from this row: " + row + " whose belonging to a "
                        + row.getTableType() + "table. " + getTableType() + "'s " + columns[i].getName()
                        + " column does not allow NAValues, but the specified "
                        + "row has a null value for that column.";
                throw new FatalDBUtilLibException(error);
            } else if (row.values[j] == null)
                this.values[i] = columns[i].getNAValue();
            else if (columns[i].getJavaType() == DBDefines.DATE && row.values[j] != null)
                this.values[i] = ((Date) row.values[j]).clone();
            else
                this.values[i] = row.values[j];
        }
        setDataSource(row.getDataSource());
        try {
            this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            throw new FatalDBUtilLibException("Error in Row constructor when creating RowID. " + e.getMessage());
        }
    }

    /**
     * This Row copy constructor returns a new row that has the same values as the input row except that the foreign
     * keys are remapped according to the input remap table. For example, if the current row has a foreign key column
     * named ORID with a value of 123 and the remap table has an entry for ORID that specified that 123 should be
     * remapped to 456, this row's orid value will be changed from 123 to 456. These remapped values are "deep" copies
     * while all other values are "shallow" copies.
     *
     * @param row   the Row object whose original and remapped values will go into the row being constructed
     * @param remap remap table for remapping values in the specified row to new values in the row being constructed
     * @throws DanglingForeignKeyPointerException if an error occurs involving a foreign key that is not pointing to
     *                                            anything
     * @throws FatalDBUtilLibException            if an error occurs
     */
    public Row(Row row, RemapTable remap) throws FatalDBUtilLibException, DanglingForeignKeyPointerException {
        this(row, row.table, remap);
    }

    /**
     * This Row copy constructor returns a new row that has the same values as the input row except that the foreign
     * keys are remapped according to the input remap table. For example, if the current row has a foreign key column
     * named ORID with a value of 123 and the remap table has an entry for ORID that specified that 123 should be
     * remapped to 456, this row's orid value will be changed from 123 to 456. These remapped values are "deep" copies
     * while all other values are "shallow" copies. This new row belongs to the specified Table and copies values from
     * the specified row into the new row if those values are allowed in the specified table. If the new row and the old
     * row are associated with different Tables, then only values from columns that have the same names in the two
     * tables are copied. All other columns in the new Row will be set to NAValues, if that is allowed. (An exception
     * will be thrown if it is not allowed.)
     *
     * @param row      the Row object whose original and remapped values will go into the row being constructed
     * @param newTable the table with which the new row is to be associated.
     * @param remap    remap table for remapping values in the specified row to new values in the row being constructed
     * @throws DanglingForeignKeyPointerException if an error occurs involving a foreign key that is not pointing to
     *                                            anything
     * @throws FatalDBUtilLibException            if an error occurs
     */
    // Interesting historical note: Sandy called this constructor the Row constructor that could take over the world. :)
    // Many errors can occur here, so a good portion of this method is spent detecting and generating useful error
    // messages for problems
    public Row(Row row, Table newTable, RemapTable remap) throws FatalDBUtilLibException,
            DanglingForeignKeyPointerException {
        this.status = row.status;
        this.sqlUndo = row.sqlUndo;
        this.history = (row.history == null) ? null : new StringBuffer(row.history.toString());
        this.table = newTable;
        setDataSource(row.getDataSource());

        // Initialize values to have as many entries as there are target table columns.
        Column[] columns = newTable.getColumns();
        this.values = new Object[columns.length];

        Column[] origColumns = row.getTable().getColumns();
        // Copy specified row values into new row
        for (int newIndex = 0; newIndex < this.values.length; newIndex++) {
            // For the current column and value
            // newIndex: index into new Row's value array
            // newCol: Column for data in new Row's values array (at this.values[newIndex])
            // origIndex: index of this column in the specified row
            // origCol: Column for data in the specified row
            // origValue: data in the specified row
            Column newCol = columns[newIndex];
            int origIndex = row.getTable().getColumnIndex(newCol.name);

            // origIndex < 0 means that the original table does not have a column that corresponds
            // to targetCol. Set values[targetIndex] to NAVALUE if allowed and go on to next column.
            if (origIndex < 0) {
                if (!newCol.NAValueAllowed())
                    throw new FatalDBUtilLibException("Error in Row constructor when creating a row from " + row
                            + " belonging to a " + row.getTableType() + " table for a " + newTable.getTableType()
                            + "table. " + newCol.getName() + " (in the new row) does not allow NAValues, but the "
                            + "original row does not have this column");
                this.values[newIndex] = newCol.NAValue;
                continue;
            }

            Column origCol = origColumns[origIndex];
            Object origValue = row.values[origIndex];

            // Deal with case where origValue is null. This null value will have to be turned into the na_value for the
            // the corresponding newCol column. If newCol does not allow for na_values, throw an exception
            if (origValue == null) {
                if (!newCol.NAValueAllowed())
                    throw new FatalDBUtilLibException("Error in Row constructor when creating a row from " + row
                            + " belonging to a " + row.getTableType() + " table for a " + newTable.getTableType()
                            + "table. " + newCol.getName() + " (in the new row) does not allow NAValues, but the "
                            + "original row has null for this column's value");

                this.values[newIndex] = newCol.NAValue;
                continue;
            }

            // If origValue is the NAValue for newCol and newCol does not allow NA Values, throw an exception.
            // Otherwise, set the corresponding newValue to the navalue
            if (newCol.equalsNAValue(origValue)) {
                if (!newCol.NAValueAllowed())
                    throw new FatalDBUtilLibException("Error in Row constructor when creating a row from " + row
                            + " belonging to a " + row.getTableType() + " table for a " + newTable.getTableType()
                            + "table. " + newCol.getName() + " (in the new row) does not allow NAValues, but the "
                            + "original row has an navalue for this column's value");
                this.values[newIndex] = newCol.NAValue;
                continue;
            }

            // At this point, we know that sourceValue is not null and is not equal to the navalue.
            // Thus, we should have a valid value - hoorah!

            // Determine if we need to remap the origVal to a new value using the remap table
            String foreignKey = newCol.foreignKey;

            // If this newCol is not a foreign key, should not be changed (newCol.fixedFK is true), or there is no remap
            // table, no need to remap the value - just add it to the values for this target row that is being created
            if (foreignKey == null || newCol.fixedFK || remap == null) {
                this.values[newIndex] = row.values[origIndex];
                continue;
            }

            // Handle remapping the foreign key. If the foreign key starts with DBDefines.VALUEOF, foreign key column
            // names must be evaluated at run time (see comments accompanying DBDefines.VALUEOF). At this point, the
            // foreign key will have something like VALUEOF:[col] where [col] is the name of the actual foreign key
            // column.
            if (foreignKey.startsWith(DBDefines.VALUEOF))
                foreignKey = row.getValueString(foreignKey.substring(DBDefines.VALUEOF.length())).toUpperCase();

            // newVal is the new value that the source value has been remapped to.
            long newVal = -1;

            // The remap source is needed to look up this foreign key column name in the remap table
            String remapSource = row.getSchema().getRemapSource(foreignKey);
            if (remapSource != null) {
                // find the remap value in the remap table.
                Long remapValue = remap.getCurrentId(remapSource, foreignKey, (Long) origValue);

                if (remapValue != null)
                    // got a valid value from the remap table. make a deep copy.
                    newVal = remapValue.longValue();
            }

            // There is no remap value for this foreign key. If the target table allows navalues for this foreign key,
            // then just set it to the navalue. Otherwise, throw an exception
            if (newVal == -1) {
                if (newCol.NAValueAllowed()) {
                    if (newCol.NAValue == null)
                        this.values[newIndex] = null;
                    else
                        this.values[newIndex] = newCol.NAValue;
                }
                // At this point ... there is no remap value for this foreign key, and it cannot be set to an navalue.
                // This error message is VERBOSE. This is because users were having trouble understanding what causes
                // this error.
                else {
                    String error = "\nDangling Foreign Key Error in Row constructor:\n\tsourceRow = " + row
                            + "    targetTable = " + newTable.getName()
                            + "    remapTable: (not shown)\nTrying to create a target table (" + newTable.getName()
                            + ") copy of the source row (" + row + ").\n" + row + "'s " + origCol.getName()
                            + " column (with value " + origValue
                            + ") is a foreign key and must thus be remapped to an appropriate value in\nthe "
                            + "target table before it can be a valid target row.  However, the remap table does not "
                            + "have an entry from\n" + origCol.getName() + " " + origValue
                            + " -> [some target value].\n(Also, " + newTable.getName()
                            + " does not allow na_values in its " + newCol.getName() + " column, " + "so the source "
                            + origCol.getName() + " cannot be set to an na_value.)\n";
                    Table sourceIdOwnerTable = row.getSchema().ownedIDToTable.get(foreignKey);
                    throw new DanglingForeignKeyPointerException(error.toString(), row, sourceIdOwnerTable, origCol,
                            origValue);
                }
            }
            // There is a remap value for this foreign key - make a deep copy of the foreign key
            // value and assign it to the target row.
            else
                this.values[newIndex] = Long.valueOf(newVal);
        }

        // All columns have been copied from sourceRow to a new row in the target.
        this.rowId = new RowID(this);
    }

    /**
     * Returns the values in this Row.
     *
     * @return Object[] representing the values found in this Row.
     */
    public Object[] getValues() {
        return this.values;
    }

    /**
     * Returns the value found in the columnIndex'th column for this Row as a String.
     *
     * @param columnIndex index of the column that has the value to be returned as a String
     * @return the value found in the columnIndex'th column for this Row as a String.
     */
    public String getValueString(int columnIndex) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueString for a " + getTableType() + " row\ncolumnIndex: "
                    + columnIndex + " is either < 0 or greater than the number of available columns.\nReturning null.");
            return null;
        }
        return getValueString(columnIndex, false);
    }

    /**
     * Returns the value found in column name for this Row as a String
     *
     * @param columnName of the column that has the value to be returned as a String
     * @return value found in columnName as a String
     */
    public String getValueString(String columnName) {
        int colIndex = this.table.getColumnIndex(columnName);
        if (colIndex == -1) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueString" + "\nccolumnName: " + columnName
                    + " does not exist in " + getTableType() + " table.\nReturning null.");
            return null;
        }
        return getValueString(colIndex);
    }

    /**
     * Returns the value found in the columnIndex'th column for this Row as a String.
     *
     * @param columnIndex index of the column that has the value to be returned as a String
     * @param widen       if true, then width of each value field is made to be the width specified by the external format
     *                    specifier.
     * @return the value found in the columnIndex'th column for this Row as a String.
     */
    public String getValueString(int columnIndex, boolean widen) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueString for a " + getTableType() + "row\ncolumnIndex: "
                    + columnIndex + " is either < 0 or greater than the number of available columns.\nReturning null.");
            return null;
        }
        // Since the values are placed in the same order as the column names they are the values for, return
        // this.values[columnIndex].
        return this.table.getColumns()[columnIndex].valueToString(this.values[columnIndex], widen);
    }

    /**
     * Returns the value found in column name for this Row as a String.
     *
     * @param columnName of the column that has the value to be returned as a String
     * @param widen      if true, then width of each value field is made to be the width specified by the external format
     *                   specifier.
     * @return value found in columnName as a String
     */
    public String getValueString(String columnName, boolean widen) {
        int colIndex = this.table.getColumnIndex(columnName);
        if (colIndex == -1) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueString" + "\nccolumnName: " + columnName
                    + " does not exist in " + getTableType() + "table.\nReturning null.");
            return null;
        }
        return getValueString(colIndex, widen);
    }

    /**
     * Returns the value found in column name for this Row as a String but does not generate an error if a column named
     * columnName does not exist.
     *
     * @param columnName of the column that has the value to be returned as a String
     * @return value found in columnName as a String; null if it does not exist
     */
    public String getValueStringNoError(String columnName) {
        int colIndex = this.table.getColumnIndex(columnName);
        if (colIndex == -1)
            return null;
        return getValueString(colIndex);
    }

    /**
     * Returns a single string containing all the values in this row.
     *
     * @param widen     if true, the width of each value field is made to be the width specified by the external format
     *                  specifier in this row's table
     * @param delimeter the character that should be used to separate the values
     * @return a single String containing all the values in this row.
     */
    public String valuesToString(boolean widen, char delimeter) {
        return valuesToString(widen, delimeter, false);
    }

    /**
     * Returns a single string containing all the values in this row.
     *
     * @param widen              if true, the width of each value field is made to be the width specified by the external format
     *                           specifier in this row's table
     * @param delimeter          the character that should be used to separate the values
     * @param scientificNotation whether or not to use scientific notation in the output string
     * @return a single String containing all the values in this row.
     */
    public String valuesToString(boolean widen, char delimeter, boolean scientificNotation) {
        StringBuilder s = new StringBuilder();
        Column[] columns = this.table.getColumns();
        for (int i = 0; i < this.values.length; i++) {
            if (i > 0)
                s.append(delimeter);
            s.append(columns[i].valueToString(this.values[i], widen, scientificNotation));
        }
        return s.toString();
    }

    /**
     * Get the value of the column at the given column index as a Double.
     *
     * @param columnIndex index of the column to get the value of
     * @return value of column in the given row as a Double
     */
    public Double getValueAsDouble(int columnIndex) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsDouble for a " + getTableType() + "row\ncolumnIndex: "
                    + columnIndex + " is either < 0 or greater than the number of available columns.\nReturning null.");
            return null;
        }

        Object val = getValue(columnIndex);
        if (!(val instanceof Double)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsDouble: value was "
                    + "either null or not a Double for column index " + columnIndex + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }
        return (Double) val;
    }

    /**
     * Get the value at the given column name as a Double.
     *
     * @param columnName name of column to get value for
     * @return value at the given column name as a Double
     */
    public Double getValueAsDouble(String columnName) {
        Object val = getValue(columnName);
        if (!(val instanceof Double)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsDouble: value was "
                    + "either null or not a Double for column name " + columnName + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }
        return (Double) val;
    }

    /**
     * Get the value of the column at the given column index as an Integer.
     *
     * @param columnIndex index of the column to get the value of
     * @return value of column in the given row as an Integer
     */
    public Integer getValueAsInt(int columnIndex) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsInt for a " + getTableType() + "row\ncolumnIndex: "
                    + columnIndex + " is either < 0 or greater than the number of available columns.\nReturning null.");
            return null;
        }

        Object val = getValue(columnIndex);
        if (!(val instanceof Integer)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsInt: value was "
                    + "either null or not an Integer for column index " + columnIndex + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }

        return (Integer) val;
    }

    /**
     * Get the value at the given column name as an Integer
     *
     * @param columnName name of column to get value for
     * @return value at the given column name as an Integer
     */
    public Integer getValueAsInt(String columnName) {
        Object val = getValue(columnName);
        if (!(val instanceof Integer)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsInt: value was "
                    + "either null or not an Integer for column name " + columnName + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }
        return (Integer) val;
    }

    /**
     * Get the value of the column at the given column index as a Long.
     *
     * @param columnIndex index of the column to get the value of
     * @return value of column in the given row as a Long
     */
    public Long getValueAsLong(int columnIndex) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsLong for a " + getTableType() + "row\ncolumnIndex: "
                    + columnIndex + " is either < 0 or greater than the number of available columns.\nReturning null.");
            return null;
        }

        Object val = getValue(columnIndex);
        if (!(val instanceof Long)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsLong: value was "
                    + "either null or not a Long for column index " + columnIndex + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }

        return (Long) val;
    }

    /**
     * Get the value at the given column name as a Long
     *
     * @param columnName name of column to get value for
     * @return value at the given column name as a Long
     */
    public Long getValueAsLong(String columnName) {
        Object val = getValue(columnName);
        if (!(val instanceof Long)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValueAsLong: value was "
                    + "either null or not a Long for column name " + columnName + " in row: "
                    + valuesToString(false, ',') + ".  Returning null.");
            return null;
        }

        return (Long) val;
    }

    /**
     * Returns the value found in the column named columnName for this Row.
     *
     * @param columnName name of the column that has the value to be retrieved
     * @return Object representing the value found in the column columnName; null if that column does not exist
     */
    public Object getValue(String columnName) {
        // Make sure that columnName is a String that could be a valid column name.
        if ((columnName == null) || (columnName.length() == 0)) {
            DBDefines.ERROR_LOG.add("Error in Row.getValue for a " + getTableType() + "table\n\tcolumnName: "
                    + columnName + "\n" + columnName + " is either null or length 0.  Returning null.");
            return null;
        }

        int colIndex = this.table.getColumnIndex(columnName);
        if (colIndex == -1) {
            DBDefines.ERROR_LOG.add("Error in Row.getValue" + "\n\tcolumnName: " + columnName + "\n" + columnName
                    + " does not exist in " + getTableType() + " table\nReturning null.");
            return null;
        }

        return getValue(colIndex);
    }

    /**
     * Returns the value found at the column specified by column index for this Row.
     *
     * @param columnIndex index of the column that has the value to be retrieved
     * @return Object representing the value found in column index; null if that column does not exist
     */
    public Object getValue(int columnIndex) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.getValue for a " + getTableType() + "row\n\tindex: " + columnIndex
                    + "\nindex is either < 0 or greater than the number of" + " available columns.\nReturning null.");
            return null;
        }
        // Since the values are placed in the same order as the column
        // names they are the values for, return this.values[column index].
        return this.values[columnIndex];
    }

    /**
     * Retrieve a HashMap of column name -> value pairs. Column names are uppercase Strings and values are Objects.
     *
     * @return a HashMap of column name -> value pairs. Column names are uppercase Strings and values are Objects.
     */
    public HashMap<String, Object> getValueMap() {
        HashMap<String, Object> valueMap = new HashMap<String, Object>(this.values.length);
        Column[] columns = this.table.getColumns();
        for (int i = 0; i < this.values.length; i++)
            valueMap.put(columns[i].getName(), this.values[i]);
        return valueMap;
    }

    /**
     * Get the value of the ownedID held by this row, if it has one.
     *
     * @return the value of the ownedID held by this table. Returns null if this row comes from a non-idowner table.
     */
    public Long getValueOwnedID() {
        if (this.table.getOwnedID() == null)
            return null;
        return getValueAsLong(this.table.getOwnedID());
    }

    /**
     * Update the field in the column with the specified name with the String value in newValue. This String will be
     * cast to the appropriate type for the column it is updating.
     *
     * @param columnName the name of the column whose value should be updated
     * @param newValue   the new value for the field in this Row; this will be cast to the appropriate type for the column
     *                   it is updating
     * @return true if update successful, false if error occurred.
     */
    public boolean updateFieldString(String columnName, String newValue) {
        // Make sure all of the parameters are more or less what they are expected to be.
        if (columnName == null || newValue == null || columnName.length() == 0) {
            DBDefines.ERROR_LOG.add("Error in Row.updateField for a " + getTableType() + "row\n\tcolumnName: "
                    + columnName + "\n\tnewValue: " + newValue + "\nField not updated.\n");
            return false;
        }

        int columnIndex = this.table.getColumnIndex(columnName);
        try {
            updateField(columnIndex, this.table.getColumns()[columnIndex].cast(newValue));
        } catch (FatalDBUtilLibException e) {
            String msg = "Error in Row.updateFieldString" + "\n\tcolumnName: " + columnName + "\n\t newValue: "
                    + newValue + "Error message: " + e.getMessage() + "\n";
            DBDefines.ERROR_LOG.add(msg);
            return false;
        }
        return true;
    }

    /**
     * Update the field in the column with the specified name with the value in newValue.
     *
     * @param columnName the name of the column whose value should be updated
     * @param newValue   the new value for the field in this Row
     * @return true if update successful, false if error occurred.
     */

    public boolean updateField(String columnName, Object newValue) {
        // Make sure all of the parameters are more or less what they are expected to be.
        if (columnName == null || newValue == null || columnName.length() == 0) {
            DBDefines.ERROR_LOG.add("Error in Row.updateField for a " + getTableType() + "table\n\tcolumnName: "
                    + columnName + "\n\tnewValue: " + newValue + "\nField not updated.\n");
            return false;
        }
        return updateField(this.table.getColumnIndex(columnName), newValue);
    }

    /**
     * Update the field in the column at column index with the String value in newValue. This String will be cast to the
     * appropriate type for the column it is updating.
     *
     * @param columnIndex index of the column whose value should be updated
     * @param newValue    the new value for the field in this Row; this will be cast to the appropriate type for the column
     *                    it is updating
     * @return true if update successful, false if error occurred.
     */
    public boolean updateFieldString(int columnIndex, String newValue) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.updateFieldString" + "\ncolumnIndex: " + columnIndex
                    + " is either < 0 or greater " + "than the number of available columns.\nReturning null.");
            return false;
        }

        try {
            updateField(columnIndex, this.table.getColumns()[columnIndex].cast(newValue));
        } catch (FatalDBUtilLibException e) {
            String msg = "Error in Row.updateFieldString for a " + getTableType() + " row\n\ti: " + columnIndex
                    + "\n\t newValue: " + newValue + "Error message: " + e.getMessage() + "\n";
            DBDefines.ERROR_LOG.add(msg);
            return false;
        }
        return true;
    }

    /**
     * Update the field in the column at column index with the value in newValue.
     *
     * @param columnIndex index of the column whose value should be updated
     * @param newValue    the new value for the field in this Row
     * @return true if update successful, false if error occurred.
     */
    public boolean updateField(int columnIndex, Object newValue) {
        // Make sure the field name was there to begin with.
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length) {
            DBDefines.ERROR_LOG.add("Error in Row.updateField" + "\ncolumnIndex: " + columnIndex
                    + " is either < 0 or greater " + "than the number of available columns.\nReturning null.");
            return false;
        }

        // Update the field.
        this.values[columnIndex] = newValue;
        // Name gets built only when it is requested. It it had been built previously, it is no longer valid.
        this.name = null;

        // Recompute RowID
        try {
            if (columnIndex != this.table.getIndexOfLDDATE())
                this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.updateField for a " + getTableType() + " row\n\tindex: " + columnIndex
                    + "\n\t newValue: " + newValue + "\nError message: " + e.getMessage() + "\n";
            DBDefines.ERROR_LOG.add(error);
            return false;
        }
        return true;
    }

    /**
     * Update the value of the AUTH field in this row, if it has one.
     *
     * @param auth the String value to put into the AUTH field of this row.
     * @throws FatalDBUtilLibException if an error occurs
     */
    public void updateAuth(String auth) {
        if (this.table.getIndexOfAUTH() < 0)
            return;
        this.values[this.table.getIndexOfAUTH()] = auth;
        try {
            this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            DBDefines.ERROR_LOG.add("Error in row.updateAuth for a " + getTableType() + "row\n\tauth: " + auth
                    + "\nAuth not updated.\nError message: " + e.getMessage());
        }
    }

    /**
     * Get the number of fields (columns) in this row.
     *
     * @return the number of fields (columns) in this row.
     */
    public int getFieldCount() {
        return this.table.getColumns().length;
    }

    /**
     * Returns a String containing this row's column names with the value associated with that column name in the format
     * below: <br>
     * lat:123, lon: 123, depth: 0, time: 123456789, orid: 123, evid: 456 etc ..
     *
     * @return a String containing this row's column names with the value associated with that column name in the format
     * below: <br>
     * lat:123, lon: 123, depth: 0, time: 123456789, orid: 123, evid: 456 etc ..
     */
    public String columnToValueString() {
        StringBuilder returnStr = new StringBuilder();
        Column[] columns = this.table.getColumns();
        for (int i = 0; i < columns.length; i++)
            returnStr.append(columns[i].getName().toLowerCase() + "=" + getValueString(i) + ", ");

        // Remove that last ", "
        return returnStr.substring(0, returnStr.length() - 2);
    }

    /**
     * Get the name of the columnIndex'th column in this row.
     *
     * @param columnIndex the index of the column whose name is desired.
     * @return the name of the columnIndex'th column in this row. Returns null if columnIndex is out of range.
     */
    public String getColumnName(int columnIndex) {
        if (columnIndex < 0 || columnIndex >= this.table.getColumns().length)
            return null;
        return this.table.getColumns()[columnIndex].name;
    }

    /**
     * Returns the names of the Columns in the table this Row is associated with.
     *
     * @return array of Strings where each String is the name of a column in the table this Row is associated with
     */
    public String[] getColumnNames() {
        Column[] columns = this.table.getColumns();
        String[] columnNames = new String[columns.length];
        // Get the names for all the columns.
        for (int i = 0; i < columns.length; i++)
            columnNames[i] = columns[i].getName();
        return columnNames;
    }

    /**
     * Returns the Table object this Row is associated with
     *
     * @return Table object this Row is associated with
     */
    public Table getTable() {
        return this.table;
    }

    /**
     * Returns the name of the table this Row is associated with
     *
     * @return name of the table this Row is associated with
     */
    public String getTableName() {
        return this.table.getName();
    }

    /**
     * Returns the type of the table this Row is associated with
     *
     * @return type of the table this Row is associated with
     */
    public String getTableType() {
        return this.table.getTableType();
    }

    /**
     * Return a reference to the Schema object that this row belongs to.
     *
     * @return a reference to the Schema object that this row belongs to.
     */
    public Schema getSchema() {
        return this.table.getSchema();
    }

    /**
     * Returns this Row's name.
     *
     * @return this Row's name.
     */
    public String getName() {
        // For space reasons, only generate and keep this if it's requested.
        if (this.name == null)
            this.name = generateName();

        return this.name;
    }

    /**
     * Create a String identifier for this Row. This identifier consists of the name of this row's table followed by
     * values defined in this row's table's row name components (see {@link Table#getRowNameComponents()
     * Table.getRowNameComponents()}.
     *
     * @return String identifier for this Row
     */
    protected String generateName() {
        if (this.values == null)
            return "null";

        // Get the row name components
        String[] rowNameComponents = this.table.getRowNameComponents();

        // Start the name off with the name of the table.
        StringBuilder rowName = new StringBuilder(this.table.getName());

        // For each of row name component columns, append the value for that column
        Column[] columns = this.table.getColumns();
        for (int j = 0; j < rowNameComponents.length; j++) {
            int i = this.table.getColumnIndex(rowNameComponents[j]);
            rowName.append(DBDefines.DELIMITER + columns[i].valueToString(this.values[i], false));
        }
        return rowName.toString();
    }

    /**
     * Return a string version of this row.
     *
     * @return a string version of this row (see {@link #getName() getName()})
     */
    @Override
    public String toString() {
        return getName();
    }

    /**
     * Creates and returns a copy of this object. The new Row object will be associated with the same Table as this row
     * object and will have a new values array (Object []) that contains deep copies of the elements of the values array
     * that are specified to be of type STRING, DATE, FLOAT, LONG, INTEGER, BOOLEAN or BYTE. Columns that have a
     * JavaType that is not in the preceding list will have shallow copies.
     *
     * @return a Row object that is a clone of this Row object.
     */
    @Override
    public Row clone() {
        Column[] columns = this.table.getColumns();

        // make a deep copy of the values[].
        Object[] vals = new Object[this.values.length];
        for (int i = 0; i < this.values.length; i++)
            if (columns[i].getJavaType() == DBDefines.DATE && this.values[i] != null)
                vals[i] = ((Date) this.values[i]).clone();
            else
                // For non date formats, a shallow copy has the same effect as a deep copy.
                vals[i] = this.values[i];

        try {
            Row row = new Row(this.table, vals, false);
            row.status = this.status;
            row.dataSource = this.dataSource;
            this.rowId = new RowID(this);
            return row;
        } catch (FatalDBUtilLibException e) {
            DBDefines.ERROR_LOG.add("Error in Row.clone().\nError message: " + e.getMessage()
                    + "\nReturning a null row.");
            return null;
        }
    }

    /**
     * Equality definition for two rows. The rows are equal if and only if they have the same ROWID, which is equivalent
     * to saying that they come from schemas that have the same name, from tables that have the same type, and all of
     * their data values except LDDATE are equal.
     *
     * @param otherRow the other row to which this row is to be compared
     * @return true if the rows have the same ROWID.
     */
    @Override
    public boolean equals(Object otherRow) {
        if (!otherRow.getClass().toString().equals(this.getClass().toString()))
            return false;
        return this.rowId.equals(((Row) otherRow).getRowId());
    }

    /**
     * Evaluate equality of two rows based on independently specified column indexes; the two rows are equal if this
     * row's value at column index thisColIndex equals otherRow's value at column index otherColIndex. Equality of data
     * values of types float and double are evaluated using a tolerance specified by the external format specifier in
     * the table definition table entry for the appropriate column.
     *
     * @param otherRow      the other Row to which this Row is to be compared.
     * @param thisColIndex  the index of the column in this Row which will serve as the basis for the comparison
     * @param otherColIndex the index of the column in otherRow that will serve as the basis for the comparison
     * @return true if the values in the two columns are equal.
     */
    public boolean equals(Row otherRow, int thisColIndex, int otherColIndex) {
        return this.table.getColumns()[thisColIndex].evaluateEquality(getValue(thisColIndex), otherRow
                .getValue(otherColIndex));
    }

    /**
     * Evaluate equality of two rows based on a list of column indexes; the two rows are equal if this row's value at
     * column index i is equal to other row's value at column index i. Equality of data values of types float and double
     * are evaluated using a tolerance specified by the external format specifier in the table definition table entry
     * for the appropriate column.
     *
     * @param otherRow the other Row to which this Row is to be compared.
     * @param indexes  column indexes which are to serve as the basis of the comparison
     * @return false if columns.length == 0, if the values have different javaTypes, or if any one of the columns have
     * values that are not equal.
     */
    public boolean equals(Row otherRow, int[] indexes) {
        if (indexes.length == 0)
            return false;
        Column[] columns = this.table.getColumns();
        for (int i = 0; i < indexes.length; i++) {
            // Column that has the necessary evaluateEquality method
            Column column = columns[indexes[i]];
            if (!column.evaluateEquality(this.values[indexes[i]], otherRow.values[indexes[i]]))
                return false;
        }
        return true;
    }

    /**
     * Evaluate equality of two rows based on independently specified column names; the two rows are equal if this row's
     * column name value equals otherRow's column name value. Equality of data values of types float and double are
     * evaluated using a tolerance specified by the external format specifier in the table definition table entry for
     * the appropriate column.
     *
     * @param otherRow the other Row to which this Row is to be compared.
     * @param thisCol  column name in this Row which will serve as the basis for the comparison
     * @param otherCol column name in otherRow that will serve as the basis for the comparison
     * @return true if the values in the two columns are equal.
     */
    public boolean equals(Row otherRow, String thisCol, String otherCol) {
        int j = this.table.getColumnIndex(thisCol);
        if (j < 0)
            return false;
        return this.table.getColumns()[j].evaluateEquality(getValue(j), otherRow.getValue(otherCol));
    }

    /**
     * Returns the number of values in the Row. For a valid Row, this is the same as the number of columns in the Table
     * that the Row belongs to.
     *
     * @return number of values contained in the row. Returns -1 if the row is not valid.
     */
    public int size() {
        if (!valid())
            return -1;
        return this.values.length;
    }

    /**
     * Return the status of this row in the context of a merge operation as a string.
     *
     * @return the status of this row in the context of a merge operation as a string.
     */
    public String getStatusString() {
        switch (this.status) {
            case DBDefines.UNDETERMINED:
                return "UNDETERMINED";
            case DBDefines.DROP:
                return "DROP";
            case DBDefines.DELETE:
                return "DELETE";
            case DBDefines.INSERT:
                return "INSERT";
            case DBDefines.UPDATE:
                return "UPDATE";
            case DBDefines.FIX_ID:
                return "FIX_ID";
            case DBDefines.FORCE_NEW_ID:
                return "FORCE_NEW_ID";
            case DBDefines.FORCE_UPDATE:
                return "FORCE_UPDATE";
            case DBDefines.INVALID:
                return "INVALID";
            default:
                return "UNDETERMINED";
        }
    }

    /**
     * Return the status of this row in the context of a merge operation. This will return a status value from one of
     * the following DBDefines values:
     * <p>
     * {@link DBDefines#UNDETERMINED DBDefines.UNDETERMINED}<br>
     * {@link DBDefines#DROP DBDefines.DROP}<br>
     * {@link DBDefines#DELETE DBDefines.DELETE}<br>
     * {@link DBDefines#INSERT DBDefines.INSERT}<br>
     * {@link DBDefines#UPDATE DBDefines.UPDATE}<br>
     * {@link DBDefines#FIX_ID DBDefines.FIX_ID}<br>
     * {@link DBDefines#FORCE_NEW_ID DBDefines.FORCE_NEW_ID}<br>
     * {@link DBDefines#FORCE_UPDATE DBDefines.FORCE_UPDATE}<br>
     * {@link DBDefines#INVALID DBDefines.INVALID}<br>
     *
     * @return the status of this row in the context of a merge operation
     */
    public int getStatus() {
        return this.status;
    }

    /**
     * Return whether or not the status of this row in the context of a merge operation is equal to the specified test
     * value.
     *
     * @param testValue value to compare to this row's status for equality
     * @return whether or not the status of this row in the context of a merge operation is equal to the specified test
     * value.
     */
    public boolean getStatus(int testValue) {
        return testValue == this.status;
    }

    /**
     * Set the status of this row.
     *
     * @param status what to set the status of this row to
     */
    public void setStatus(int status) {
        this.status = status;
        if (status == DBDefines.DELETE)
            this.sqlUndo = undoDelete();
        else if (status == DBDefines.UPDATE)
            this.sqlUndo = undoUpdate(this);
        else
            this.sqlUndo = null;
    }

    /**
     * Set the status of this row to update and specify the row whose information will be updating this row's
     * information.
     *
     * @param targetRow row that will update this row's information
     */
    public void setStatusUpdate(Row targetRow) {
        this.status = DBDefines.UPDATE;
        this.sqlUndo = undoUpdate(targetRow);
    }

    /**
     * Test validity of this Row object.
     *
     * @return true if Row's values array is not null and is not empty.
     */
    public boolean valid() {
        if (this.values == null || this.values.length == 0)
            return false;
        return true;
    }

    /**
     * Recomputes this Row's RowID. This is rarely necessary since a Row's RowID is computed at the conclusion of each
     * Row constructor and each time any of the data in a Row is updated with any of the updateField() methods.
     *
     * @return a reconstructed RowID for this row
     * @throws FatalDBUtilLibException if an error occurs
     */
    public RowID resetRowID() throws FatalDBUtilLibException {
        try {
            this.rowId = new RowID(this);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.resetRowId() when retrieving RowID.\n" + "Error message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
        return this.rowId;
    }

    /**
     * Get the ROWID of this row.
     *
     * @return the ROWID of this row.
     */
    public RowID getRowId() {
        return this.rowId;
    }

    /**
     * Return the JavaType of the values in some column of this row. javaTypes are byte values which are defined in
     * DBDefines. Currently defined values include: <br>
     * UNKNOWN_TYPE<br>
     * STRING<br>
     * LONG <br>
     * DOUBLE<br>
     * FLOAT<br>
     * DATE<br>
     * INTEGER<br>
     * BOOLEAN<br>
     * BYTE<br>
     * BIG_DECIMAL<br>
     * BLOB<br>
     * CLOB<br>
     * TIMESTAMP<br>
     * <p>
     * For example, to test if the "WIDGET" column of this row is of type DOUBLE (for example), use: <br>
     * if (row.getJavaType("WIDGET") == DBDefines.DOUBLE) ... This method returns {@link DBDefines#UNKNOWN_TYPE
     * DBDefines.UNKNOWN_TYPE} if the specified column name does not exist in this row's table
     *
     * @param columnName the name of the column in this row's table whose javaType is being requested.
     * @return the javaType of the specified column in the table that this row belongs to; returns
     * {@link DBDefines#UNKNOWN_TYPE DBDefines.UNKNOWN_TYPE} if the specified column name does not exist in this row's
     * table
     */
    public byte getJavaType(String columnName) {
        Column col = this.table.getColumn(columnName);
        if (col == null)
            return DBDefines.UNKNOWN_TYPE;
        return col.getJavaType();
    }

    /**
     * Returns the NAValue for a particular column. This method returns null if the column name does not exist in this
     * row's table
     *
     * @param columnName the name of the column in this row's table whose NAValue is being requested.
     * @return the NAValue of the specified column in the table this row belongs to. Returns null if the column name
     * does not exist in this row's table
     */
    public Object getNAValue(String columnName) {
        Column col = this.table.getColumn(columnName);
        if (col == null)
            return null;
        return col.NAValue;
    }

    /**
     * Returns whether or not the Object in value equals the specified column in this row's table's NAValue.
     *
     * @param columnName the name of the column in this row's table whose value's equality with the column's NAValue is
     *                   to be tested.
     * @param value      the Object being compared against the column in this row's table NAValue to see if they are equal.
     * @return true if value equals the specified column in this row's table's NAValue; false otherwise
     */
    public boolean equalsNAValue(String columnName, Object value) {
        Column col = this.table.getColumn(columnName);
        if (col == null)
            return false;
        return col.equalsNAValue(value);
    }

    /**
     * Returns the external format for a particular column. This method returns "" if the column name does not exist in
     * this row's table
     *
     * @param columnName the name of the column in this row's table whose external format is being requested.
     * @return the external format of the specified column in the table this row belongs to. Returns "" if the column
     * name does not exist in this row's table
     */
    public String getExternalFormat(String columnName) {
        Column col = this.table.getColumn(columnName);
        if (col == null)
            return "";
        return col.externalFormat;
    }

    /**
     * Sets this row's LDDATE (if this row has a LDDATE column) to the specified date.
     *
     * @param date value to set this row's LDDATE column value to (if this row has a LDDATE column)
     * @return whether or not the LDDATE was set successfully. If this row does not have a LDDATE column, this method
     * will return false
     */
    public boolean setLDDATE(Date date) {
        if (this.table.getIndexOfLDDATE() >= 0) {
            updateField(this.table.getIndexOfLDDATE(), date);
            return true;
        }
        return false;
    }

    /**
     * Return this row's history that documents what has happened to this row in the context of a merge. This method
     * returns "" if this row's history has not been activated.
     *
     * @return this row's history that documents what has happened to this row in the context of a merge; "" if this
     * row's history has not been activated
     */
    public String getHistory() {
        if (this.history == null)
            return "";
        return this.history.toString();
    }

    /**
     * Add an entry to this row's history (if this row has a history). Nothing is done if its history is not turned on.
     *
     * @param entry to add to this row's history
     */
    public void addToHistory(String entry) {
        if (this.history != null)
            this.history.append(entry);
    }

    /**
     * Add an error message to the LinkedList of error messages that are associated with this Row.
     *
     * @param errorMessage to add to the LinkedList of error messages that are associated with this Row.
     */
    public void addError(String errorMessage) {
        if (this.errors == null)
            this.errors = new LinkedList<String>();
        this.errors.add(errorMessage);
    }

    /**
     * Return the error messages that are related to this Row. During row graph construction, when this row is the
     * source row, and execution of any of its relationship objects generates a constraint violation, then the sql
     * select statement that generated the violation is added to this list.
     *
     * @return error messages associated with this Row; null if there are none.
     */
    public LinkedList<String> getErrors() {
        return this.errors;
    }

    /**
     * Set the name of the data source from which this Row originated. For Rows from a database, this should be the
     * username of the DB. For Rows that originated from files, it should be the directory name. For rows generated by
     * applications, it should be set to the name of the application.
     *
     * @param dataSourceName new data source to use for the information in this Row
     */
    public void setDataSource(String dataSourceName) {
        if (dataSourceName != null && !dataSourceName.equals(this.table.getDataSource()))
            this.dataSource = dataSourceName;
    }

    /**
     * Get the name of the data source from which this Row originated. For Rows from a database, this will be the
     * username of the DB. For Rows that originated from files, it will be the directory where the file resides. For
     * rows generated by applications, it should be the name of the application.
     *
     * @return data source for information in this row
     */
    public String getDataSource() {
        if (this.dataSource == null)
            return this.table.getDataSource();
        return this.dataSource;
    }

    /**
     * Returns a Jaxb version of this Row.
     *
     * @return a Jaxb version of this Row
     * @throws JAXBException if an error occurs during the jaxb DAO object construction
     */
    public gov.sandia.gnem.dbutillib.jaxb.Row toJaxb() throws JAXBException {
        ObjectFactory of = new ObjectFactory();
        gov.sandia.gnem.dbutillib.jaxb.Row jaxbRow = of.createRow();

        if (this.rowId != null)
            jaxbRow.setRowId(this.rowId.getRowIDHex());
        else
            jaxbRow.setRowId("");
        jaxbRow.setDataSourceName(getDataSource());
        List<gov.sandia.gnem.dbutillib.jaxb.Row.Field> fields = jaxbRow.getField();
        Column[] columns = this.table.getColumns();

        // The order of the values corresponds to the order of the Columns in the Column array within this Row's Table.
        for (int i = 0; i < this.values.length; i++) {
            gov.sandia.gnem.dbutillib.jaxb.Row.Field field = of.createRowField();
            field.setCol(columns[i].getName());
            if (this.values[i] == null)
                field.setVal("");
            else
                field.setVal(columns[i].valueToString(this.values[i], false, true));

            fields.add(field);
        }

        return jaxbRow;
    }

    /**
     * Creates a DBUtilLib Row from a Jaxb Row.
     *
     * @param jaxbRow jaxb row used to create a DBUtilLib Row
     * @param table   table the row to be created belongs to
     * @return a DBUtilLib row created from jaxbRow
     * @throws FatalDBUtilLibException if an error occurs during the Row object construction
     */
    public static Row fromJaxb(gov.sandia.gnem.dbutillib.jaxb.Row jaxbRow, Table table) throws FatalDBUtilLibException {
        HashMap<String, Object> values = new HashMap<String, Object>(table.getColumns().length);

        // Retrieve the values
        for (gov.sandia.gnem.dbutillib.jaxb.Row.Field field : jaxbRow.getField())
            if (field.getVal().length() > 0)
                values.put(field.getCol(), field.getVal());
            else
                values.put(field.getCol(), null);

        Row row = new Row(table, values, true, false);
        row.rowId = new RowID(jaxbRow.getRowId());
        row.setDataSource(jaxbRow.getDataSourceName());
        return row;
    }

    /**
     * DateFormatter used during creation of SQL undo statements.
     */
    private final static SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    /**
     * ORACLE to_date syntax used during the creation of SQL undo statements.
     */
    private final static String SQLdate = "TO_DATE('','yyyy-mm-dd hh24:mi:ss')";

    /**
     * Returns a sql where clause that identifies this row via primary key. For example, an origin row with orid=100
     * would return "WHERE ORID=100".
     *
     * @return a sql where clause that identifies this row via a primary key. Returns an empty string if this row has no
     * primary key.
     */
    public String getPrimaryKeyWhereClause() {
        StringBuilder whereClause = new StringBuilder();
        String delimeter = "";
        Column[] columns = this.table.getColumns();
        for (int i = 0; i < columns.length; i++) {
            if (!columns[i].getType().equalsIgnoreCase(Column.PRIMARY_KEY_COLUMN_TYPE))
                continue;

            whereClause.append(delimeter + columns[i].getName() + "=");
            if (this.values[i] == null)
                whereClause.append(" null ");
            else if (columns[i].getJavaType() == DBDefines.STRING)
                whereClause.append("'").append(this.values[i].toString()).append("'");
            else
                whereClause.append(this.values[i].toString());
            delimeter = " AND ";
        }
        if (whereClause.length() > 0)
            whereClause.insert(0, "WHERE ");
        return whereClause.toString();
    }

    /**
     * Inserts this row into the database. This method is somewhat deceptively named since it really inserts the row
     * into whatever DAO type is represented in this row's schema.
     *
     * @return whether or not the insert was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean insertIntoDB() throws FatalDBUtilLibException {
        try {
            return getSchema().getDAO().insertRow(this);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.insertIntoDB.\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
    }

    /**
     * Inserts this row into the database using the specified connection. This method is needed when the user needs to
     * have control over the connection for commit and rollback independence amongst threads.
     *
     * @return whether or not the insert was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean insertIntoDB(Connection connection) throws FatalDBUtilLibException {
        if (connection == null)
            return insertIntoDB();
        try {
            return ((DAODatabase) getSchema().getDAO()).insertRow(this, connection);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.insertIntoDB (connection).\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
    }

    /**
     * Return a SQL statement that would delete this row from the database. The idea is that this row is about to be
     * inserted into the database. This function will return a SQL statement that will delete this row in case the user
     * wants to rollback the insert; it returns null if the statement could not be created if there are no primary keys
     * to use in the where clause specifying which row to delete.
     * <p>
     * <i>Note: It is not programmatically impossible to create a SQL statement that will not do the deletes based on
     * the primary key. Please contact DBUtilLib's current maintainer if you would like this functionality added.
     *
     * @return a SQL statement that would delete this row from the database; null if the statement could not be created
     * if there are no primary keys to use in the where clause specifying which row to delete
     */

    public String undoInsert() {
        // if a table does not have primary keys, then return null because otherwise this method would return a string
        // that would delete all rows from the associated table.
        int[] primaryKeyColumnIndexes = this.table.getPrimaryKeyColumnIndexes();
        if (primaryKeyColumnIndexes.length == 0)
            return null;

        StringBuilder key = new StringBuilder("DELETE FROM " + getTableName());
        String delimeter = " WHERE ";
        Column[] columns = this.table.getColumns();

        // Get the primary column names/values.
        for (int j = 0; j < primaryKeyColumnIndexes.length; j++) {
            int i = primaryKeyColumnIndexes[j];
            key.append(delimeter + columns[i].getName() + "=");
            if (this.values[i] == null)
                key.append(columns[i].valueToString(this.values[i], false));
                // Dates require special handling to make Oracle happy
            else if (columns[i].getJavaType() == DBDefines.DATE) {
                StringBuilder dateString = new StringBuilder(SQLdate);
                dateString.insert(SQLdate.indexOf("''") + 1, dateFormatter.format((Date) this.values[i]));
                key.append(dateString);
            }
            // Surround Strings with tick marks
            else if (columns[i].getJavaType() == DBDefines.STRING)
                key.append('\'').append(this.values[i].toString()).append('\'');
            else
                key.append(columns[i].valueToString(this.values[i], false));

            // Switch the delimiter to handle compound primary keys (those that use more than one column)
            delimeter = " AND ";
        }
        key.append(";");
        return key.toString();
    }

    /**
     * Deletes this row from the database. This method is somewhat deceptively named since it really deletes the row
     * from whatever DAO type is represented in this row's schema.
     *
     * @return whether or not the delete was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean deleteFromDB() throws FatalDBUtilLibException {
        try {
            return getSchema().getDAO().deleteRow(this);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.deleteFromDB.\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
    }

    /**
     * Deletes this row from the database using the specified connection. This method is needed when the user needs to
     * have control over the connection for commit and rollback independence amongst threads.
     *
     * @return whether or not the insert was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean deleteFromDB(Connection connection) throws FatalDBUtilLibException {
        if (connection == null)
            return deleteFromDB();
        try {
            return ((DAODatabase) getSchema().getDAO()).deleteRow(this, connection);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.deleteFromDB(connection).\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
    }

    /**
     * Return a SQL statement that would restore this row in the database. The idea is that this row is about to be
     * deleted from the database. This function will return a SQL statement that will insert this row back into the
     * database in case the user wants to rollback the delete.
     *
     * @return a SQL statement that would restore this row in the database
     */
    private String undoDelete() {
        StringBuilder key = new StringBuilder("INSERT INTO " + getTableName() + " (");

        Column[] columns = this.table.getColumns();

        // Get the column names.
        for (int i = 0; i < columns.length; i++)
            key.append(columns[i].getName() + ", ");

        // Remove the last comma and space.
        key.setLength(key.length() - 2);

        // Get the values
        key.append(") VALUES (");
        for (int i = 0; i < this.values.length; i++) {
            if (this.values[i] == null)
                key.append(columns[i].valueToString(this.values[i], false));
                // Dates require special handling to make Oracle happy
            else if (i == this.table.getIndexOfLDDATE()) {
                StringBuilder dateString = new StringBuilder(SQLdate);
                dateString.insert(SQLdate.indexOf("''") + 1, dateFormatter.format((Date) this.values[i]));
                key.append(dateString);
            }
            // Surround Strings with tick marks
            else if (columns[i].getJavaType() == DBDefines.STRING)
                key.append("'" + this.values[i].toString() + "'");
            else
                key.append(columns[i].valueToString(this.values[i], false));
            key.append(", ");
        }
        // Remove the last comma and space.
        key.setLength(key.length() - 2);
        key.append(");");
        return key.toString();
    }

    /**
     * Updates this row in the database. This method is somewhat deceptively named since it really update the row in
     * whatever DAO type is represented in this row's schema.
     *
     * @return whether or not the update was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean updateInDB() throws FatalDBUtilLibException {
        try {
            getSchema().getDAO().updateRow(this);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.updateInDB.\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
        return true;
    }

    /**
     * Updates this row in the database using the specified connection. This method is needed when the user needs to
     * have control over the connection for commit and rollback independence amongst threads.
     *
     * @return whether or not the insert was successful
     * @throws FatalDBUtilLibException if an error occurs
     */
    public boolean updateInDB(Connection connection) throws FatalDBUtilLibException {
        if (connection == null)
            return updateInDB();
        try {
            return ((DAODatabase) getSchema().getDAO()).updateRow(this, connection);
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.updateInDB(connection).\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
    }

    /**
     * Return a SQL statement that would restore this row in the database to its current value. The idea is that this
     * row is about to be updated in the database with all new values except for its primary keys. This function will
     * return a SQL statement that will restore this row to its current values, based on its primary keys in case the
     * user decides to rollback the update.
     *
     * @param targetRow row whose values will be updating the current row's values
     * @return a SQL statement that would restore this row in the database to its current value.
     */
    private String undoUpdate(Row targetRow) {
        Table targetTable = targetRow.getTable();

        StringBuilder undoStatement = new StringBuilder("UPDATE " + targetTable.getName() + " SET ");
        Column[] targetTableColumns = targetTable.getColumns();
        for (int i = 0; i < targetTableColumns.length; i++) {
            // Don't update primary keys since we need them!
            if (targetTableColumns[i].getType().equals(Column.PRIMARY_KEY_COLUMN_TYPE))
                continue;

            if (targetRow.values[i] == null)
                undoStatement.append("null");
                // Dates need special processing to make Oracle happy
            else if (i == targetTable.getIndexOfLDDATE()) {
                StringBuilder dateString = new StringBuilder(SQLdate);
                // insert the date between SQLdate's ''
                dateString.insert(SQLdate.indexOf("''") + 1, dateFormatter.format((Date) targetRow.values[i]));
                undoStatement.append(targetTableColumns[i].getName() + "=" + dateString);
            } else {
                undoStatement.append(targetTableColumns[i].getName() + "=");
                // Surround strings with tick marks
                if (targetTableColumns[i].getJavaType() == DBDefines.STRING)
                    undoStatement.append("'" + targetRow.values[i].toString() + "'");
                else
                    undoStatement.append(targetRow.values[i].toString());
            }
            undoStatement.append(", ");

        }
        // Remove the last comma and space.
        undoStatement.delete(undoStatement.length() - 2, undoStatement.length());
        // Add the where clause that will be used to figure out which row is being undone
        undoStatement.append(this.getPrimaryKeyWhereClause() + ";");
        return undoStatement.toString();
    }

    /**
     * Return rows that are connected to this row through a Relationship object defined in the schema. The related Rows
     * are created by executing queries that are constructed from the information found in a Relationship in this Schema
     * where the Relationship's sourceTable equals this row's table.
     *
     * @return Row objects that are connected to row through a Relationship in this Schema
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Collection<Row> getConnectedRows() throws FatalDBUtilLibException {
        return getConnectedRows(null);
    }

    /**
     * Return rows that are connected to this row through a Relationship object defined in the schema. The related Rows
     * are created by executing queries that are constructed from the information found in a Relationship in this Schema
     * where the Relationship's sourceTable equals this row's table.
     *
     * @param omitTargetTable ignore Relationships where the targetTable is omitTargetTable.
     * @return Row objects that are connected to row through a Relationship in this Schema
     * @throws FatalDBUtilLibException if an error occurs
     */
    public Collection<Row> getConnectedRows(Table omitTargetTable) throws FatalDBUtilLibException {
        LinkedList<Row> connectedRows = new LinkedList<Row>();
        ArrayList<Relationship> relationships = this.table.getSchema().getRelationshipsForSourceTable(getTableType());

        if (relationships == null)
            return connectedRows;

        try {
            // For every relationship, extract the rows connected to this row through that relationship.
            for (Relationship relationship : relationships) {
                if (relationship.getTargetTable() == omitTargetTable)
                    continue;
                Collection<Row> rows = relationship.execute(this);
                connectedRows.addAll(rows);

                if (relationship.constraintViolated(rows.size())) {
                    getSchema().rowGraphConstraintViolation = true;
                    throw new FatalDBUtilLibException("Constraint Violation in Relationship.execute().\n\t"
                            + relationship.getSelectStatement() + "\n\treturned " + rows.size()
                            + " rows which is not allowed by the " + relationship.getConstraint() + " constraint");
                }
            }
        } catch (FatalDBUtilLibException e) {
            String error = "Error in Row.getConnectedRows().\nError message: " + e.getMessage();
            throw new FatalDBUtilLibException(error);
        }
        return connectedRows;
    }

    /**
     * Clear the undo sql buffer.
     */
    public void clearSqlUndo() {
        this.sqlUndo = "";
    }

    /**
     * Return the undo SQL buffer. If this row is going to UPDATE itself or be deleted, this undo SQL buffer has a SQL
     * UPDATE or INSERT statement that will restore the original row.
     *
     * @return the undo SQL buffer that will restore the original state of this row; returns null if this buffer hasn't
     * been set up
     */
    public String getSqlUndo() {
        return this.sqlUndo;
    }

    /**
     * This class just extends the Exception interface to create a customized exception that Row can throw when it finds
     * dangling foreign key pointers. These types of errors have caused a good deal of confusion, so it became necessary
     * to encapsulate as much information as possible about these errors in order to precisely indicate to the user why
     * the errors are occurring.
     */
    @SuppressWarnings("serial")
    public static class DanglingForeignKeyPointerException extends java.lang.Exception {
        /**
         * Row that caused the error
         */
        private Row errorRow;

        /**
         * Value that caused the error
         */
        private Object errorValue;

        /**
         * Column that caused the error
         */
        private Column errorColumn;

        /**
         * Table that owns {@link #errorColumn errorColumn}
         */
        private Table idOwnerTable;

        /**
         * Constructs an instance of <code>DanglingForeignKeyPointerException</code> with the specified detail message.
         *
         * @param msg          the detail message.
         * @param errorRow     row that caused the error
         * @param idOwnerTable table that owns the id that the dangling foreign key is pointing to
         * @param errorColumn  column generating the error
         * @param errorValue   value generating the error
         */
        public DanglingForeignKeyPointerException(String msg, Row errorRow, Table idOwnerTable, Column errorColumn,
                                                  Object errorValue) {
            super("Version: " + (Version.buildVersion.length() == 0 ? "DEVL" : Version.buildVersion) + "\n" + msg);

            this.errorRow = errorRow;
            this.idOwnerTable = idOwnerTable;
            this.errorColumn = errorColumn;
            this.errorValue = errorValue;
        }

        /**
         * Return the row that caused the error
         *
         * @return row that caused the error
         */
        public Row getErrorRow() {
            return this.errorRow;
        }

        /**
         * Return the table that owns the id that caused the error
         *
         * @return the table that owns the id that caused the error
         */
        public Table getIdOwnerTable() {
            return this.idOwnerTable;
        }

        /**
         * Return the column that caused the error
         *
         * @return the column that caused the error
         */
        public Column getErrorColumn() {
            return this.errorColumn;
        }

        /**
         * Return the value that caused the error
         *
         * @return the value that caused the error
         */
        public Object getErrorValue() {
            return this.errorValue;
        }
    }
}

// I am not sure if these methods are being used. They are not being used by other DBUtilLib classes or DBTools
// applications as of January 2009. I am leaving them here in case someone else is using them and they need to be
// restored.

// /**
// * Return whether or not this row's foreign key values equal the other row's foreign key values.
// * @param otherRow other row whose foreign keys will be compared to this row's foreign keys for equality
// * @return whether or not this row's foreign key values equal the other row's foreign key values.
// */
// public boolean equalFK(Row otherRow)
// {
// // This is a confusing concept, so here are a plethora of comments. :)
// // fkNameToIndex is a map where the key is the name of a column in another table that columns in this table
// // point to and the value is a list of column indexes is this table that point to that column in the other
// // table. For example, in the origin table, the mbid, msid, and mlid columns all refer to the magid column in
// // the netmag table. For a schema that has an origin table related to a netmag table with relationships defined
// // between mbid and magid, msid and magid, and mlid and magid, this map will have an entry that looks like:
// // magid-> 16, 18, 20
// // where 16 is mbid's index, 18 is mlid's index, and 20 is msid's index in the origin table
// HashMap<String, LinkedList<Integer>> fkNameToIndex = this.table.getFKNameToIndexMap();
//
// // Iterate over the names of all the foreign keys in this table.
// for (String id : fkNameToIndex.keySet())
// {
// // Determine if the other row has a foreign key by this name
// HashMap<String, LinkedList<Integer>> otherFkNameToIndex = otherRow.getTable().getFKNameToIndexMap();
// // Retrieve the indexes of the columns in the other rows table that are indexes
// LinkedList<Integer> otherFk = otherFkNameToIndex.get(id);
//        
// // No foreign key by this name - return false.
// if (otherFk == null)
// return false;
//        
// // Retrieve the indexes of the columns in this table that are foreign keys to id
// LinkedList<Integer> fk = fkNameToIndex.get(id);
//        
// if (otherFk.size() >= fk.size())
// {
// HashSet<Long> otherValues = new HashSet<Long>();
// for (Integer idx : otherFk)
// otherValues.add((Long) otherRow.getValue(idx));
// for (Integer idx : fk)
// if (!otherValues.contains((Long) getValue(idx)))
// return false;
// }
// else
// {
// HashSet<Long> vals = new HashSet<Long>();
// for (Integer idx : fk)
// vals.add((Long) getValue(idx));
// for (Integer idx : otherFk)
// if (!vals.contains((Long) otherRow.getValue(idx)))
// return false;
// }
// }
// return true;
// }
// /**
// * Retrieve the values of the idLink columns in this row that correspond to a specified ownedID. idLinks are foreign
// * keys that are actually involved in Relationships. The input parameter is the name of an ownedID (that id is
// * presumably owned by some table other than the table that owns this row). If the table that this row belongs to
// * has any idLinks that relate to that ownedID, find them and return the values of those columns. See Column object
// * for a more complete description of idLinks.
// * @param ownedID the ownedID whose idLink values are requested.
// * @return a list of values of the idLink columns. Returns an empty LinkedList if this row does not have any fields
// * that corresponds to the specified ownedID.
// */
// public LinkedList<Integer> getIDLinkValues(String ownedID)
// {
// LinkedList<Integer> idLinks = this.table.getFKNameToIndexMap().get(ownedID);
// LinkedList<Integer> fkValues = new LinkedList<Integer>();
// if (idLinks != null)
// for (Integer idLink : idLinks)
// fkValues.add((Integer) values[idLink]);
// return fkValues;
// }
